//
// Created by chengdaqian on 18-5-23.
//
#include <mi_explorer/mi_naive_explorer.h>
#include <sensor_msgs/PointCloud2.h>
#include <mi_explorer/naive_lattice.h>
#include <mi_explorer/mi_computer.h>
#include <pcl_ros/point_cloud.h>

bool g_is_test;

namespace mi_explorer
{
    typedef boost::recursive_mutex mutex_t;

    const static unsigned int CHECK_COLLISION_STEP_NUM = 5;

    bool cmpCandidateScore(const NodeCandidate &candidate1, const NodeCandidate &candidate2){
        if (candidate1.score > candidate2.score)
            return true;
        else
            return false;
    }

    void MINaiveExplorer::main_explore_loop()
    {
        ROS_WARN("Time flag: Loop start");
        // lock map
        boost::unique_lock<mutex_t> lock(*(prob_map_->map_->getMutex()));

        // create empty node list
        std::list<NodeCandidate> node_list;

        // construct lattice object
        NaiveLattice lattice_generator(odom_, lattice_acc_step_, lattice_time_step_, lattice_max_speed_, lattice_rho_, prob_map_);

        // generate state lattice
        lattice_generator.getMotionPrimitives(node_list);
        ROS_INFO_STREAM("Time flag: Generate lattice with " << node_list.size() << " nodes");

        // construct MIComputer object
        MIComputer mi_computer(mi_beam_num_, mi_beam_length_, prob_map_);

        // evaluate nodes generated by lattice
        mi_computer.evalNodes(node_list);
        ROS_INFO("Time flag: Evaluate nodes");

        // select node with highest mi-cost ratio
        NodeCandidate selected_node;
        pubAccCmd(selectCandidate(node_list, selected_node), selected_node);
        ROS_INFO("Time flag: Select node");

        // visualize nodes, paths
        // TODO push all free cells into node_list, visualize their mi
        visualizeNodes(node_list, selected_node);
        visualizePaths(node_list);
        ROS_INFO("Time flag: Visualize nodes and paths");

    }

    void MINaiveExplorer::test_explore_loop() {
        // lock map
        boost::unique_lock<mutex_t> lock(*(prob_map_->map_->getMutex()));

        std::list<NodeCandidate> node_list;
        NodeCandidate node;

        for (unsigned int idx = 0; idx < prob_map_->map_->getSizeInCellsX() * prob_map_->map_->getSizeInCellsX(); idx++){
            if (prob_map_->map_->getOddsRatio(idx) < 1.0){
                prob_map_->map_->indexToCells(idx, node.mx, node.my);
                prob_map_->map_->mapToWorld(node.mx, node.my, node.wx, node.wy);

                node_list.push_back(node);
            }
        }

        MIComputer mi_computer(mi_beam_num_, mi_beam_length_, prob_map_);

        // evaluate nodes generated by lattice
        mi_computer.evalNodes(node_list);
        ROS_INFO("Time flag: Evaluate nodes");

        // get max mi
        double max_mi = 0.0;
        for (auto it = node_list.begin(); it != node_list.end(); it++){
            if (it->mutual_info > max_mi)
                max_mi = it->mutual_info;
        }

        pcl::PointCloud<pcl::PointXYZI> mi_cloud_viz;
        pcl::PointXYZI mi_point_viz(50);

        for (auto it = node_list.begin(); it != node_list.end(); it++){
            mi_point_viz.x = (float)it->wx;
            mi_point_viz.y = (float)it->wy;
            mi_point_viz.intensity = 100.0 * it->mutual_info / max_mi;
            mi_cloud_viz.push_back(mi_point_viz);
        }

        sensor_msgs::PointCloud2 mi_cloud_viz_output;
        pcl::toROSMsg(mi_cloud_viz, mi_cloud_viz_output);
        mi_cloud_viz_output.header.frame_id = global_frame_name_;
        mi_cloud_viz_output.header.stamp = ros::Time::now();
        mi_field_viz_pub_.publish(mi_cloud_viz_output);
    }

    MINaiveExplorer::MINaiveExplorer(std::string global_frame_name)
            : nh_("~")
            , private_nh_("~")
            , global_frame_name_(global_frame_name)
    {
        prob_map_ = boost::shared_ptr<simple_map_2d::ProbMap2DROS>(
                new simple_map_2d::ProbMap2DROS("prob_map", global_frame_name_));
        
        odom_sub_ = private_nh_.subscribe("prob_map/odom", 2, &MINaiveExplorer::odom_cb, this);
        path_tree_viz_pub_ = private_nh_.advertise<visualization_msgs::Marker>("path_tree_viz",3);
        path_node_viz_pub_ = private_nh_.advertise<sensor_msgs::PointCloud2>  ("path_node_viz",3);
        mi_field_viz_pub_  = private_nh_.advertise<sensor_msgs::PointCloud2>  ("mi_field_viz" ,3);
        acc_pub_           = private_nh_.advertise<geometry_msgs::Vector3>    ("acc_cmd",      3);

        beam_end_viz_ = private_nh_.advertise<sensor_msgs::PointCloud2>("beam_end_viz",3);

        nh_.param<double>("update_duration",   update_duration_,   1.0);
        nh_.param<double>("lattice_acc_step",  lattice_acc_step_ , 0.2);
        nh_.param<double>("lattice_time_step", lattice_time_step_, 1.5);
        nh_.param<double>("lattice_max_speed", lattice_max_speed_, 1.0);
        nh_.param<double>("lattice_rho",       lattice_rho_,       1.0);
        
        nh_.param<int>   ("mi_beam_num_" , mi_beam_num_   , 40 );
        nh_.param<double>("/ground_range", mi_beam_length_, 5.0);

        nh_.param<bool>("/is_test", g_is_test, false);
        
        initRosMsgContainer();
    }

    bool MINaiveExplorer::selectCandidate(std::list<NodeCandidate> &node_list, NodeCandidate &selected) {

        // compute score and copy to a vector, since @sort requires random access iterator
        std::vector<NodeCandidate> node_vec(node_list.size());
        unsigned int idx = 0;
        for (auto it = node_list.begin(); it != node_list.end(); it++, idx++){
            it->score = it->mutual_info / it->travel_cost;
            node_vec[idx] = *it;
        }

        // sort candidate vector by each node's score
        std::sort(node_vec.begin(), node_vec.end(), cmpCandidateScore);

        // select the one with the highest score that is collision-free
        for (auto it = node_vec.begin(); it != node_vec.end(); it++){
            if (checkAccCollisionFree(it->acc_x, it->acc_y)){
                selected = *it;
                return true;
            }else{
                ROS_INFO_STREAM("### Abandoned collision acc_x:" << it->acc_x << ", acc_y" << it->acc_y);
            }
        }
        return false;
    }

    bool MINaiveExplorer::checkAccCollisionFree(double acc_x, double acc_y) {

        double wx0 = odom_.pose.pose.position.x, wy0 = odom_.pose.pose.position.y;
        double vx0 = odom_.twist.twist.linear.x, vy0 = odom_.twist.twist.linear.y;

        for (double iter_time = 0; iter_time < lattice_time_step_; iter_time += lattice_time_step_/CHECK_COLLISION_STEP_NUM){

            double iter_end_wx = wx0 + vx0 * iter_time + 0.5 * acc_x * iter_time * iter_time;
            double iter_end_wy = wy0 + vy0 * iter_time + 0.5 * acc_y * iter_time * iter_time;

            unsigned int iter_end_mx, iter_end_my;

            (prob_map_->map_)->worldToMap(iter_end_wx, iter_end_wy, iter_end_mx, iter_end_my);

            if ((prob_map_->map_)->getOddsRatio(iter_end_mx, iter_end_my) >= 1.0)
                return false;

        }
        return true;
    }

    void MINaiveExplorer::pubAccCmd(bool selected_valid, const NodeCandidate &selected_node) {
        if (selected_valid){ // if a valid node is selected
            geometry_msgs::Vector3 acc;
            acc.x = selected_node.acc_x;
            acc.y = selected_node.acc_y;
            acc_pub_.publish(acc);
        }else{ // if all node are abandoned
            ROS_ERROR("All nodes are invalid!!!");
            geometry_msgs::Vector3 acc;
            acc.z = 1.0;// indicates that the acc is invalid, should set speed to 0.
            acc_pub_.publish(acc);
        }
    }

    void MINaiveExplorer::initRosMsgContainer() {
        path_tree_viz_.header.frame_id = global_frame_name_;
        path_tree_viz_.action = visualization_msgs::Marker::ADD;
        path_tree_viz_.pose.orientation.w = 1.0;
        path_tree_viz_.id = 0;
        path_tree_viz_.type = visualization_msgs::Marker::LINE_LIST;
        path_tree_viz_.scale.x = 0.02;
        path_tree_viz_.color.r = path_tree_viz_.color.a = 1.0;
    }

    void MINaiveExplorer::odom_cb(const nav_msgs::Odometry &odom) {
        odom_ = odom;
    }

    void MINaiveExplorer::visualizeNodes(const std::list<NodeCandidate> &node_list, const NodeCandidate &selected) {
        pcl::PointCloud<pcl::PointXYZI> node_cloud_viz;
        pcl::PointXYZI node_point_viz(50);
        for (auto it = node_list.begin(); it != node_list.end(); it++){
            node_point_viz.x = (float)it->wx;
            node_point_viz.y = (float)it->wy;
            node_cloud_viz.push_back(node_point_viz);
        }

        node_point_viz.x = (float)selected.wx;
        node_point_viz.y = (float)selected.wy;
        node_point_viz.intensity = 80;
        node_cloud_viz.push_back(node_point_viz);

        sensor_msgs::PointCloud2 node_cloud_viz_output;
        pcl::toROSMsg(node_cloud_viz, node_cloud_viz_output);
        node_cloud_viz_output.header.frame_id = global_frame_name_;
        node_cloud_viz_output.header.stamp = ros::Time::now();
        path_node_viz_pub_.publish(node_cloud_viz_output);
    }

    void MINaiveExplorer::visualizePaths(const std::list<NodeCandidate> &node_list) {

        path_tree_viz_.points.clear();
        geometry_msgs::Point parent, child;

        double wx0 = odom_.pose.pose.position.x, wy0 = odom_.pose.pose.position.y;
        double vx0 = odom_.twist.twist.linear.x, vy0 = odom_.twist.twist.linear.y;

        for (auto it = node_list.begin(); it != node_list.end(); it++){

            double acc_x = it->acc_x, acc_y = it->acc_y;
            child.x = wx0;
            child.y = wy0;

            for (double iter_time = 0; iter_time <= lattice_time_step_; iter_time += lattice_time_step_/CHECK_COLLISION_STEP_NUM){

                parent = child;

                double iter_end_wx = wx0 + vx0 * iter_time + 0.5 * acc_x * iter_time * iter_time;
                double iter_end_wy = wy0 + vy0 * iter_time + 0.5 * acc_y * iter_time * iter_time;

                child.x = iter_end_wx;
                child.y = iter_end_wy;

                path_tree_viz_.points.push_back(parent);
                path_tree_viz_.points.push_back(child );
            }
        }

        path_tree_viz_pub_.publish(path_tree_viz_);

    }
}

int main (int argc, char** argv)
{
    ros::init(argc, argv, "prob_explorer");

    mi_explorer::MINaiveExplorer explorer("/odom");


    while (ros::ok()){
        double loop_start_time = ros::Time::now().toSec();

        ros::spinOnce();

        if (g_is_test)
            explorer.test_explore_loop();
        else
            explorer.main_explore_loop();


        while (ros::Time::now().toSec() - loop_start_time < explorer.update_duration_){
            ros::spinOnce();
            ros::Duration(0.1).sleep();
        }
    }
}